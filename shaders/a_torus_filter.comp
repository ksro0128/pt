#version 450
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba32f) uniform readonly image2D inputImage;
layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D outputImage;
layout(set = 0, binding = 2, rgba32f) uniform writeonly image2D historyImage;
layout(set = 0, binding = 3, r32f) uniform readonly image2D varianceImage;
layout(set = 0, binding = 4, r32f) uniform writeonly image2D updatedVarianceImage;

layout(set = 1, binding = 0, rgba32f) uniform readonly image2D normalImage;
layout(set = 1, binding = 1, r32f) uniform readonly image2D depthImage;
layout(set = 1, binding = 3, r32f) uniform readonly image2D meshIDImage;
layout(set = 1, binding = 4, r32f) uniform readonly image2D sampleCountImage;
layout(set = 1, binding = 6, rgba32f) uniform writeonly image2D prevNormalImage;
layout(set = 1, binding = 7, r32f) uniform writeonly image2D prevDepthImage;
layout(set = 1, binding = 8, r32f) uniform writeonly image2D prevMeshIDImage;


layout(set = 2, binding = 1) uniform OptionsGPU {
    int frameCount;
    int sampleCount;
	int maxSampleCount;
    float pad2;
} options;

layout(push_constant) uniform PushConsts {
    int stepSize;
} pc;



// float estimateSpatialVariance(ivec2 coord, vec3 centerNormal, float centerDepth) {
//     const int spatialKernelRadius = 3;
//     float totalWeight = 0.0;
//     float accum = 0.0;

//     for (int dy = -spatialKernelRadius; dy <= spatialKernelRadius; ++dy) {
//         for (int dx = -spatialKernelRadius; dx <= spatialKernelRadius; ++dx) {
//             ivec2 offset = ivec2(dx, dy);
//             ivec2 sampleCoord = clamp(coord + offset, ivec2(0), imageSize(inputImage) - 1);

//             float sampleVar = imageLoad(varianceImage, sampleCoord).r;
//             vec3 sampleNormal = normalize(imageLoad(normalImage, sampleCoord).rgb);
//             float sampleDepth = imageLoad(depthImage, sampleCoord).r;

//             float Ndot = max(0.0, dot(centerNormal, sampleNormal));
//             float w_n = pow(Ndot, sigma_n);

//             float w_z = exp(-abs(centerDepth - sampleDepth) / sigma_z);

//             float w = w_n * w_z;

//             accum += sampleVar * w;
//             totalWeight += w;
//         }
//     }

//     return (totalWeight > 0.0) ? (accum / totalWeight) : 0.0;
// }

const float sigma_n = 128.0;
const float sigma_z = 1.0;
const float sigma_c = 4.0;
const float epsilon = 1e-2;


const float kernel[5][5] = float[5][5](
    float[5](1, 4, 6, 4, 1),
    float[5](4, 16, 24, 16, 4),
    float[5](6, 24, 36, 24, 6),
    float[5](4, 16, 24, 16, 4),
    float[5](1, 4, 6, 4, 1)
);

const float kernel77[7][7] = float[7][7](
    float[7](1,  4,  6,  7,  6,  4,  1),
    float[7](4, 16, 24, 28, 24, 16, 4),
    float[7](6, 24, 36, 42, 36, 24, 6),
    float[7](7, 28, 42, 49, 42, 28, 7),
    float[7](6, 24, 36, 42, 36, 24, 6),
    float[7](4, 16, 24, 28, 24, 16, 4),
    float[7](1,  4,  6,  7,  6,  4,  1)
);


void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(inputImage);

    vec3 centerColor = imageLoad(inputImage, coord).rgb;
    vec3 centerNormal = normalize(imageLoad(normalImage, coord).rgb);
    float centerDepth = imageLoad(depthImage, coord).r;
    float centerMeshID = imageLoad(meshIDImage, coord).r;

    if (pc.stepSize == 1) {
        imageStore(prevNormalImage, coord, vec4(centerNormal, 1.0));
        imageStore(prevDepthImage, coord, vec4(centerDepth));
        imageStore(prevMeshIDImage, coord, vec4(centerMeshID));
    }

    float centerL = dot(centerColor, vec3(0.299, 0.587, 0.114));

    float sigma_l = 0.0;
    float spp = imageLoad(sampleCountImage, coord).r;
    // if (spp < 4 && pc.stepSize == 1) {
    //     float spatialVar = estimateSpatialVariance(coord, centerNormal, centerDepth);
    //     sigma_l = sqrt(max(spatialVar, epsilon));
    // }
    // else {
    //     sigma_l = sqrt(max(imageLoad(varianceImage, coord).r, epsilon));
    // }
    sigma_l = sqrt(max(imageLoad(varianceImage, coord).r, epsilon));

    // depth gradient
    float dzdx = imageLoad(depthImage, clamp(coord + ivec2(1, 0), ivec2(0), imageSize - 1)).r -
                 imageLoad(depthImage, clamp(coord - ivec2(1, 0), ivec2(0), imageSize - 1)).r;
    float dzdy = imageLoad(depthImage, clamp(coord + ivec2(0, 1), ivec2(0), imageSize - 1)).r -
                 imageLoad(depthImage, clamp(coord - ivec2(0, 1), ivec2(0), imageSize - 1)).r;
    vec2 dzdp = vec2(dzdx, dzdy);

    vec3 accum = vec3(0.0);
    float accumVar = 0.0;
    float totalWeight = 0.0;
    int kernelRadius = 2;
    if (spp < 4 && pc.stepSize > 1) {
        imageStore(outputImage, coord, vec4(centerColor, 1.0));
        return; 
    }
    else if (spp < 4 && pc.stepSize == 1) {
        kernelRadius = 3;
    }

    for (int dy = -kernelRadius; dy <= kernelRadius; ++dy) {
        for (int dx = -kernelRadius; dx <= kernelRadius; ++dx) {
            ivec2 offset = ivec2(dx, dy) * pc.stepSize;
            ivec2 sampleCoord = clamp(coord + offset, ivec2(0), imageSize - 1);

            vec3 sampleColor = imageLoad(inputImage, sampleCoord).rgb;
            vec3 sampleNormal = normalize(imageLoad(normalImage, sampleCoord).rgb);
            float sampleDepth = imageLoad(depthImage, sampleCoord).r;

            // normal weight
            float Ndot = max(0.0, dot(centerNormal, sampleNormal));
            float w_n = pow(Ndot, sigma_n);

            // depth weight
            vec2 pixelOffset = vec2(dx, dy) * float(pc.stepSize);
            float gradProj = abs(dot(dzdp, pixelOffset));
            float w_z = exp(-abs(centerDepth - sampleDepth) / (sigma_z * gradProj + epsilon));

            // luminance weight
            float sampleL = dot(sampleColor, vec3(0.299, 0.587, 0.114));
            float deltaL = abs(centerL - sampleL);
            float w_l = exp(-deltaL / (sigma_l * sigma_c + epsilon));
            float spatialWeight = 0.0;
            if (spp < 4) {
                w_l = 1.0;
                spatialWeight = kernel77[dy + kernelRadius][dx + kernelRadius];
            }
            else {
                spatialWeight = kernel[dy + kernelRadius][dx + kernelRadius];
            }

            float w = spatialWeight * w_n * w_z * w_l;

            accum += sampleColor * w;
            totalWeight += w;

            float sampleVar = imageLoad(varianceImage, sampleCoord).r;
            accumVar += w * w * sampleVar;
        }
    }

    vec3 filtered = (totalWeight > 0.0) ? (accum / totalWeight) : vec3(0.0);
    float updatedVar = (totalWeight > 0.0) ? (accumVar / (totalWeight * totalWeight + epsilon)) : 0.0;

    imageStore(outputImage, coord, vec4(filtered, 1.0));
    imageStore(updatedVarianceImage, coord, vec4(updatedVar));
    if (pc.stepSize == 1) {
        imageStore(historyImage, coord, vec4(filtered, 1.0));
    }
}