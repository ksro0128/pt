#version 450
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba32f) uniform readonly image2D inputImage;
layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D outputImage;

layout(set = 1, binding = 0, rgba32f) uniform readonly image2D normalImage;
layout(set = 1, binding = 1, r32f) uniform readonly image2D depthImage;

layout(push_constant) uniform PushConsts {
    int stepSize;
} pc;

const int kernelRadius = 2;
const float sigma_n = 128.0;
const float sigma_z = 1.0;
const float epsilon = 1e-2;


const float kernel[5][5] = float[5][5](
    float[5](1, 2, 3, 2, 1),
    float[5](2, 4, 6, 4, 2),
    float[5](3, 6, 9, 6, 3),
    float[5](2, 4, 6, 4, 2),
    float[5](1, 2, 3, 2, 1)
);

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(inputImage);

    vec3 centerNormal = normalize(imageLoad(normalImage, coord).rgb);
    float centerDepth = imageLoad(depthImage, coord).r;

    // depth gradient
    float dzdx = imageLoad(depthImage, clamp(coord + ivec2(1, 0), ivec2(0), imageSize - 1)).r -
                 imageLoad(depthImage, clamp(coord - ivec2(1, 0), ivec2(0), imageSize - 1)).r;
    float dzdy = imageLoad(depthImage, clamp(coord + ivec2(0, 1), ivec2(0), imageSize - 1)).r -
                 imageLoad(depthImage, clamp(coord - ivec2(0, 1), ivec2(0), imageSize - 1)).r;
    vec2 dzdp = vec2(dzdx, dzdy);

    vec3 accum = vec3(0.0);
    float totalWeight = 0.0;

    for (int dy = -kernelRadius; dy <= kernelRadius; ++dy) {
        for (int dx = -kernelRadius; dx <= kernelRadius; ++dx) {
            ivec2 offset = ivec2(dx, dy) * pc.stepSize;
            ivec2 sampleCoord = clamp(coord + offset, ivec2(0), imageSize - 1);

            vec3 sampleColor = imageLoad(inputImage, sampleCoord).rgb;
            vec3 sampleNormal = normalize(imageLoad(normalImage, sampleCoord).rgb);
            float sampleDepth = imageLoad(depthImage, sampleCoord).r;

            // normal weight
            float Ndot = max(0.0, dot(centerNormal, sampleNormal));
            float w_n = pow(Ndot, sigma_n);

            // depth weight
            vec2 pixelOffset = vec2(dx, dy) * float(pc.stepSize);
            float gradProj = abs(dot(dzdp, pixelOffset));
            float w_z = exp(-abs(centerDepth - sampleDepth) / (sigma_z * gradProj + epsilon));

            // spatial + edge weights
            float spatialWeight = kernel[dy + kernelRadius][dx + kernelRadius];
            float w = spatialWeight * w_n * w_z;

            accum += sampleColor * w;
            totalWeight += w;
        }
    }

    vec3 filtered = (totalWeight > 0.0) ? (accum / totalWeight) : vec3(0.0);
    imageStore(outputImage, coord, vec4(filtered, 1.0));
}