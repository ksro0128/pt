#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

struct MaterialGPU {
	int type;
	int index;
	float pad0;
	float pad1;
};

struct UberGPU {
	vec3 Kd;
	float pad0;
    
	vec3 Ks;
	float pad1;

    vec3 Kr;
	float pad2;

    vec3 Kt;
	float pad3;

    vec3 opacity;
	float pad4;

    int KdIdx;
    int KsIdx;
    int KrIdx;
    int KtIdx;

    int opacityIdx;
    float eta;
	int etaIdx;
    float uroughness;

	int uroughnessIdx;
	float vroughness;
	int vroughnessIdx;
    int remaproughness;
};

struct MatteGPU {
	vec3 Kd;
	float pad0;

	int KdIdx;
	float sigma;
	int sigmaIdx;
	float pad1;
};

struct MetalGPU {
	vec3 eta;
	float pad0;
	
	vec3 k;
	float pad1;
	
	int etaIdx;
	int kIdx;
	float uroughness;
	int uroughnessIdx;

	float vroughness;
	int vroughnessIdx;
	int remaproughness;
	float pad2;
};

struct GlassGPU {
	vec3 Kr;
	float pad0;

	vec3 Kt;
	float pad1;


	int KrIdx;
	int KtIdx;
	float eta;
	int etaIdx;


	float uroughness;
	int uroughnessIdx;
	float vroughness;
	int vroughnessIdx;

	int remaproughness;
	float pad2;
	float pad3;
	float pad4;
};

struct MirrorGPU {
	vec3 Kr;
	float pad0;

	int KrIdx;
	float pad1;
	float pad2;
	float pad3;
};

struct SubstrateGPU {
	vec3 Kd;
	float pad0;

	vec3 Ks;
	float pad1;

	int KdIdx;
	int KsIdx;
	float uroughness;
	int uroughnessIdx;

	float vroughness;
	int vroughnessIdx;
	int remaproughness;
	float pad2;
};

struct PlasticGPU {
	vec3 Kd;
	float pad0;
	vec3 Ks;
	float pad1;

	
	int KdIdx;
	int KsIdx;
	float roughness;
	int roughnessIdx;

	
	int remaproughness;
	float pad2;
	float pad3;
	float pad4;
};

struct ShapeGPU {
	mat4 modelMatrix;
	
	uint64_t vertexAddress;
	uint64_t indexAddress;
	
	int materialIdx;
	int areaLightIdx;
	int alphaIdx;
	int shadowAlphaIdx;
	
	int reverseOrientation;
	float pad0;
	float pad1;
	float pad2;
};

struct AreaLightGPU {
	vec3 scale;
	float pad0;
	vec3 L;
	float pad1;

	int twosided;
	int samples;
	float pad2;
	float pad3;

	vec4 pad4;
};

layout(set = 0, binding = 0) uniform CameraGPU {
    vec3 camPos;
    float pad0;
    vec3 camDir;
    float pad1;
    vec3 camUp;
    float pad2;
    vec3 camRight;
    float fovY;
} camera;

layout(set = 0, binding = 1) uniform OptionsGPU {
    int frameCount;
    int sampleCount;
	int maxSampleCount;
    float pad2;
} options;

layout(set = 0, binding = 2) uniform PrevCameraGPU {
    vec3 camPos;
    float pad0;
    vec3 camDir;
    float pad1;
    vec3 camUp;
    float pad2;
    vec3 camRight;
    float fovY;
} prevCamera;

layout(set = 1, binding = 0) readonly buffer instanceBuffer {
    ShapeGPU instances[];
};

layout(set = 2, binding = 0) readonly buffer AreaLightBuffer { 
    AreaLightGPU lights[]; 
};
layout(set = 2, binding = 1) readonly buffer MaterialBuffer { 
    MaterialGPU materials[]; 
};
layout(set = 2, binding = 2) readonly buffer UberBuffer { 
    UberGPU ubers[];
};
layout(set = 2, binding = 3) readonly buffer MatteBuffer { 
    MatteGPU mattes[];
};
layout(set = 2, binding = 4) readonly buffer MetalBuffer { 
    MetalGPU metals[]; 
};
layout(set = 2, binding = 5) readonly buffer GlassBuffer { 
    GlassGPU glasses[]; 
};
layout(set = 2, binding = 6) readonly buffer MirrorBuffer { 
    MirrorGPU mirrors[]; 
};
layout(set = 2, binding = 7) readonly buffer SubstrateBuffer { 
    SubstrateGPU substrates[]; 
};
layout(set = 2, binding = 8) readonly buffer PlasticBuffer { 
    PlasticGPU plastics[]; 
};

layout(set = 3, binding = 0) uniform sampler2D textures[];

layout(set = 4, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 4, binding = 1, rgba32f) uniform image2D directAccumImage;
layout(set = 4, binding = 2, rgba32f) uniform image2D directOutputImage;
layout(set = 4, binding = 3, rgba32f) uniform image2D indirectAccumImage;
layout(set = 4, binding = 4, rgba32f) uniform image2D indirectOutputImage;

layout(set = 4, binding = 5, r32f) uniform image2D directM1Image;
layout(set = 4, binding = 6, r32f) uniform image2D directM2Image;
layout(set = 4, binding = 7, r32f) uniform image2D indirectM1Image;
layout(set = 4, binding = 8, r32f) uniform image2D indirectM2Image;

layout(set = 4, binding = 9, r32f) uniform image2D directVarianceImage;
layout(set = 4, binding = 10, r32f) uniform image2D indirectVarianceImage;

layout(set = 5, binding = 0, rgba32f) uniform image2D normalImage;
layout(set = 5, binding = 1, r32f) uniform image2D depthImage;
layout(set = 5, binding = 2, rgba32f) uniform image2D albedoImage;
layout(set = 5, binding = 3, r32f) uniform image2D meshIDImage;
layout(set = 5, binding = 4, r32f) uniform image2D sampleCountImage;
layout(set = 5, binding = 5, rg32f) uniform image2D motionVectorImage;
layout(set = 5, binding = 6, rgba32f) uniform image2D prevNormalImage;
layout(set = 5, binding = 7, r32f) uniform image2D prevDepthImage;
layout(set = 5, binding = 8, r32f) uniform image2D prevMeshIDImage;
layout(set = 5, binding = 9, rg32f) uniform image2D jitterImage;
layout(set = 5, binding = 10, rg32f) uniform image2D prevJitterImage;


float rand(inout uint seed) {
    seed ^= seed << 13;
    seed ^= seed >> 17;
    seed ^= seed << 5;
    return float(seed) / 4294967296.0;
}

uint tea(in uint val0, in uint val1)
{
  uint v0 = val0;
  uint v1 = val1;
  uint s0 = 0;

  for(uint n = 0; n < 16; n++)
  {
    s0 += 0x9e3779b9;
    v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
    v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
  }

  return v0;
}

uint initRandom(in uvec2 resolution, in uvec2 screenCoord, in uint frame)
{
  return tea(screenCoord.y * resolution.x + screenCoord.x, frame);
}

float radicalInverse_VdC(uint bits) {
    bits = (bits << 16) | (bits >> 16);
    bits = ((bits & 0x55555555u) << 1) | ((bits & 0xAAAAAAAAu) >> 1);
    bits = ((bits & 0x33333333u) << 2) | ((bits & 0xCCCCCCCCu) >> 2);
    bits = ((bits & 0x0F0F0F0Fu) << 4) | ((bits & 0xF0F0F0F0u) >> 4);
    bits = ((bits & 0x00FF00FFu) << 8) | ((bits & 0xFF00FF00u) >> 8);
    return float(bits) * 2.3283064365386963e-10; // 1/2^32
}

float radicalInverseBase3(uint n) {
    float invBase = 1.0 / 3.0;
    float result = 0.0;
    float f = invBase;
    while (n > 0u) {
        result += float(n % 3u) * f;
        n /= 3u;
        f *= invBase;
    }
    return result;
}

vec2 halton(uint index) {
    return vec2(
        radicalInverse_VdC(index),       // base 2
        radicalInverseBase3(index)       // base 3
    );
}

float luminance(vec3 x) {
	return dot(x, vec3(0.2126, 0.7152, 0.0722));
}

const vec2 JITTER_SEQ[16] = vec2[16](
    vec2(0.5,     0.3333),  // Halton(1)
    vec2(0.25,    0.6667),  // Halton(2)
    vec2(0.75,    0.1111),  // Halton(3)
    vec2(0.125,   0.4444),  // Halton(4)
    vec2(0.625,   0.7778),  // Halton(5)
    vec2(0.375,   0.2222),  // Halton(6)
    vec2(0.875,   0.5556),  // Halton(7)
    vec2(0.0625,  0.8889),  // Halton(8)
    vec2(0.5625,  0.0370),  // Halton(9)
    vec2(0.3125,  0.3704),  // Halton(10)
    vec2(0.8125,  0.7037),  // Halton(11)
    vec2(0.1875,  0.1481),  // Halton(12)
    vec2(0.6875,  0.4815),  // Halton(13)
    vec2(0.4375,  0.8148),  // Halton(14)
    vec2(0.9375,  0.2593),  // Halton(15)
    vec2(0.03125, 0.5926)   // Halton(16)
);


struct RayPayload {
    vec3 L_direct;
    vec3 L_indirect;
    vec3 beta;
	vec3 normal;
    vec3 nextOrigin;
    vec3 nextDir;
	vec3 albedo;
    vec3 indirAlbedo;
    int bounce;
    uint seed;
    int terminated;
	float depth;
	int meshID;
    float pdf;
};

layout(location = 0) rayPayloadEXT RayPayload payload;


vec3 toneMapACES(vec3 x) {
    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);
}


void main() {
    uvec2 pixel = gl_LaunchIDEXT.xy;
    uvec2 size = gl_LaunchSizeEXT.xy;
    
	vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(size);

	// vec2 jitterPix  = JITTER_SEQ[options.frameCount % 15] - vec2(0.5);
	// vec2 uv = (vec2(pixel) + jitterPix) / vec2(size);

	// uint seed = initRandom(size, pixel, options.frameCount);
	// vec2 jitter = vec2(rand(seed), rand(seed));
	// vec2 uv = (vec2(pixel) + jitter) / vec2(size);

	// uint seed = initRandom(size, pixel, options.frameCount);
	// float jitter_x = rand(seed);
	// float jitter_y = rand(seed);
	// vec2 jitter = vec2(jitter_x, jitter_y);
	// vec2 uv = (vec2(pixel) + vec2(0.5) + jitter / 2 - vec2(0.5)) / vec2(size);

	// imageStore(jitterImage, ivec2(pixel), vec4(jitter, 0.0, 1.0));

    vec2 screen = uv * 2.0 - 1.0;
	screen.x = -screen.x;
    screen.y = -screen.y;
    float aspect = float(size.x) / float(size.y);
    float scale = tan(radians(camera.fovY) * 0.5);

    vec3 dir = normalize(
        screen.x * aspect * scale * camera.camRight +
        screen.y * scale * camera.camUp +
        camera.camDir
    );
	vec3 currentDir = dir;

	payload.L_direct = vec3(0.0);
	payload.L_indirect = vec3(0.0);
	payload.beta = vec3(1.0);
	payload.seed = initRandom(size, pixel, options.frameCount);
	// payload.seed = options.frameCount;
	payload.bounce = 0;
	payload.terminated = 0;
	payload.normal = vec3(0.0);
	payload.albedo = vec3(1.0);
	payload.depth = 0.0;
	payload.pdf = 0.0;
	payload.indirAlbedo = vec3(1.0);

	vec3 origin = camera.camPos;
	ivec2 ipixel = ivec2(pixel);
	vec3 albedo = vec3(1.0);
	vec3 indirAlbedo = vec3(1.0);

	vec3 currentNormal = vec3(0.0);
	float currentDepth = 0.0;
	int currentMeshID = -1;
	int mirror = 0;

	for (int i = 0; i < 4; ++i) {
		payload.bounce = i;
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0,
					origin, 0.0001, dir, 1e30, 0);
		
		if (mirror == 1) {
			currentNormal = payload.normal;
			currentDepth = payload.depth;
			currentMeshID = payload.meshID;
			albedo = payload.albedo;
			indirAlbedo = payload.indirAlbedo;
			mirror = -1;
		}
		if (i == 0) {
			if (payload.bounce != 1) {
				mirror = 1;
			}
			else {
				currentDepth = payload.depth;
				currentNormal = payload.normal;
				currentMeshID = payload.meshID;
				albedo = payload.albedo;
				indirAlbedo = payload.indirAlbedo;
			}
		}
		if (payload.terminated != 0) break;

		if (i > 2) {
			float p = clamp(max(payload.beta.r, max(payload.beta.g, payload.beta.b)), 0.05, 1.0);
			if (rand(payload.seed) > p) {
				break;
			}
			payload.beta /= p;
		}

		origin = payload.nextOrigin;
		dir = payload.nextDir;
	}

	imageStore(albedoImage, ipixel, vec4(albedo, 1.0));

	if (mirror == -1) {
		imageStore(normalImage, ipixel, vec4(currentNormal, 1.0));
		imageStore(depthImage, ipixel, vec4(currentDepth));
		imageStore(meshIDImage, ipixel, vec4(float(currentMeshID)));
	}
	else {
		currentNormal = imageLoad(normalImage, ipixel).xyz;
		currentDepth = imageLoad(depthImage, ipixel).r;
		currentMeshID = int(imageLoad(meshIDImage, ipixel).r);
	}



	// vec3 worldPos = camera.camPos + currentDir * currentDepth;

	// float prevScale = tan(radians(prevCamera.fovY) * 0.5);
	// vec3 rel = worldPos - prevCamera.camPos;

	// float dx = dot(rel, prevCamera.camRight);
	// dx = -dx;
	// float dy = dot(rel, prevCamera.camUp);
	// dy = -dy;
	// float dz = dot(rel, prevCamera.camDir);
	// float safeDZ = max(abs(dz), 1e-2);

	// vec2 prevNDC;
	// prevNDC.x = dx / (safeDZ * aspect * prevScale);
	// prevNDC.y = dy / (safeDZ * prevScale);
	// vec2 prevUV = prevNDC * 0.5 + 0.5;

	// vec2 jitterPrev = imageLoad(prevJitterImage, ipixel).rg;
	// vec2 pixelSize = 1.0 / vec2(size);
	// prevUV += (jitterPrev - jitter) * pixelSize;

	uv = (vec2(pixel) + vec2(0.5)) / vec2(size);
	vec2 motion = imageLoad(motionVectorImage, ipixel).rg;
	vec2 prevUV = uv - motion;

	ivec2 res = ivec2(size);
	ivec2 prevPixel = ivec2(prevUV * vec2(res) - 0.5);
	prevPixel = clamp(prevPixel, ivec2(0), res - 1);

	vec2 f = fract(prevUV * vec2(res) - 0.5);
	float W[4] = float[4](
		(1.0 - f.x) * (1.0 - f.y), // (0,0)
		f.x * (1.0 - f.y),         // (1,0)
		(1.0 - f.x) * f.y,         // (0,1)
		f.x * f.y                  // (1,1)
	);

	ivec2 OFF[4] = ivec2[4](ivec2(0,0), ivec2(1,0), ivec2(0,1), ivec2(1,1));
	float totalW = 0.0;

	vec4 acc_direct = vec4(0.0);
	vec4 acc_indirect = vec4(0.0);
	float acc_m1_dir = 0.0, acc_m2_dir = 0.0;
	float acc_m1_ind = 0.0, acc_m2_ind = 0.0;
	float acc_fc = 0.0;

	for (int i = 0; i < 4; ++i) {
		ivec2 p = clamp(prevPixel + OFF[i], ivec2(0), res - 1);

		vec3 n = imageLoad(prevNormalImage, p).xyz;
		float d = imageLoad(prevDepthImage, p).r;
		float id = imageLoad(prevMeshIDImage, p).r;

		float ndot = dot(currentNormal, n);
		float ddiff = abs(d - currentDepth) / max(currentDepth, 1e-2);
		bool match = abs(id - currentMeshID) < 0.5;

		if (ndot > 0.98 && ddiff < 0.2 && match) {
			float w = W[i];
			acc_direct += imageLoad(directAccumImage, p) * w;
			acc_m1_dir += imageLoad(directM1Image, p).r * w;
			acc_m2_dir += imageLoad(directM2Image, p).r * w;
			acc_indirect += imageLoad(indirectAccumImage, p) * w;
			acc_m1_ind += imageLoad(indirectM1Image, p).r * w;
			acc_m2_ind += imageLoad(indirectM2Image, p).r * w;
			acc_fc += imageLoad(sampleCountImage, p).r * w;
			totalW += w;
		}
	}
	
	bool consistent = totalW > 0.0;
	if (consistent) {
		acc_direct /= totalW;
		acc_m1_dir /= totalW;
		acc_m2_dir /= totalW;
		acc_indirect /= totalW;
		acc_m1_ind /= totalW;
		acc_m2_ind /= totalW;
		acc_fc /= totalW;
	}
	else {
		acc_direct = vec4(0.0);
		acc_indirect = vec4(0.0);
		acc_m1_dir = acc_m2_dir = 0.0;
		acc_m1_ind = acc_m2_ind = 0.0;
		acc_fc = 0.0;
		totalW = 0.0;

		for (int dy = -1; dy <= 1; ++dy) {
			for (int dx = -1; dx <= 1; ++dx) {
				ivec2 p = clamp(prevPixel + ivec2(dx, dy), ivec2(0), res - 1);

				vec3 n = imageLoad(prevNormalImage, p).xyz;
				float d = imageLoad(prevDepthImage, p).r;
				float id = imageLoad(prevMeshIDImage, p).r;

				float ndot = dot(currentNormal, n);
				float ddiff = abs(d - currentDepth) / max(currentDepth, 1e-2);
				bool match = abs(id - currentMeshID) < 0.5;

				if (ndot > 0.98 && ddiff < 0.2 && match) {
					acc_direct += imageLoad(directAccumImage, p);
					acc_m1_dir += imageLoad(directM1Image, p).r;
					acc_m2_dir += imageLoad(directM2Image, p).r;
					acc_indirect += imageLoad(indirectAccumImage, p);
					acc_m1_ind += imageLoad(indirectM1Image, p).r;
					acc_m2_ind += imageLoad(indirectM2Image, p).r;
					acc_fc += imageLoad(sampleCountImage, p).r;
					totalW += 1.0;
				}
			}
		}

		if (totalW > 0.0) {
			acc_direct /= totalW;
			acc_m1_dir /= totalW;
			acc_m2_dir /= totalW;
			acc_indirect /= totalW;
			acc_m1_ind /= totalW;
			acc_m2_ind /= totalW;
			acc_fc /= totalW;
			consistent = true; // fallback 성공
		}
	}

	vec3 safeIndirAlbedo = max(indirAlbedo, vec3(0.01));

	payload.L_indirect /= safeIndirAlbedo;

	vec4 directResult   = vec4(payload.L_direct,   1.0);
	vec4 indirectResult = vec4(payload.L_indirect, 1.0);

	float alpha  = consistent ? 0.05 : 1.0;
	float fcOld  = consistent ? acc_fc : 0.0;
	float fcNext = fcOld + 1.0;

	float directLum = luminance(directResult.rgb);
	float updatedM1Dir = (acc_m1_dir * fcOld + directLum) / fcNext;
	float updatedM2Dir = (acc_m2_dir * fcOld + directLum * directLum) / fcNext;
	vec4  directCurrent = mix(acc_direct, directResult, alpha);
	float directVar = max(updatedM2Dir - updatedM1Dir * updatedM1Dir, 0.0);

	float indirectLum = luminance(indirectResult.rgb);
	float updatedM1Ind = (acc_m1_ind * fcOld + indirectLum) / fcNext;
	float updatedM2Ind = (acc_m2_ind * fcOld + indirectLum * indirectLum) / fcNext;
	vec4  indirectCurrent = mix(acc_indirect, indirectResult, alpha);
	float indirectVar = max(updatedM2Ind - updatedM1Ind * updatedM1Ind, 0.0);

	imageStore(directOutputImage, ipixel, directCurrent);
	imageStore(directM1Image, ipixel, vec4(updatedM1Dir));
	imageStore(directM2Image, ipixel, vec4(updatedM2Dir));
	imageStore(directVarianceImage, ipixel, vec4(directVar));

	imageStore(indirectOutputImage, ipixel, indirectCurrent);
	imageStore(indirectM1Image, ipixel, vec4(updatedM1Ind));
	imageStore(indirectM2Image, ipixel, vec4(updatedM2Ind));
	imageStore(indirectVarianceImage, ipixel, vec4(indirectVar));

	imageStore(sampleCountImage, ipixel, vec4(fcNext));
}